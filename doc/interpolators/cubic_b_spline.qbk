[/
Copyright (c) 2017 Nick Thompson
Use, modification and distribution are subject to the
Boost Software License, Version 1.0. (See accompanying file
LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:cubic_b Cubic B-spline interpolation]

[section:cubic_b_over Overview of Cubic B-Spline Interpolation]

The cubic b spline class provided by boost allows fast and accurate interpolation of a function which is known at equally spaced points.
The cubic b-spline interpolation is preferable to traditional cubic spline interpolation as the global support of cubic polynomials makes the interpolation ill-conditioned.

There are many use cases for interpolating a function at equally spaced points.
One particularly important example is solving ODE's whose coefficients depend on data determined from experiment or numerically.
Since most ODE steppers are adaptive, they must be able to sample the coefficients at arbitrary points; not just at the points we know the values of our function.

The constructor must be provided the following arguments:

* A vector containing data
* The length of the vector
* The start of the functions domain
* The step size

Optionally, you may provide two additional arguments to the constructor, namely the derivative of the function at the left endpoint, and the derivative at the right endpoint.
If you do not provide these arguments, they will be estimated using one-sided finite-difference formulas.
An example of a valid call to the constructor is

    __auto spline = boost::math::cubic_b_spline<double>(f.data(), f.size(), t0, h);

(which requests the derivatives to be estimated) or

    __auto spline = boost::math::cubic_b_spline<double>(f.data(), f.size(), t0, h, a_prime, b_prime);

which explicitly provides the endpoint derivatives.

To evaluate the interpolant at a point, we simply use

    __auto y = spline(x);

and to evaluate the derivative we use

    __auto yp = spline.prime(x);

Be aware that the accuracy guarantees on the derivative of the spline are much lower than the guarantees on the original function; see

Finally, note that this is an [*interpolator], not an extrapolator.
Therefore, you should strenuously avoid evaluating the spline outside the endpoints.
However, it is not an error if you do, as often you cannot control where (say) an ODE stepper will evaluate your function.
As such the interpolant tries to do something reasonable when the function is outside the endpoints.
For evaluation within one stepsize of the interval, you can assume something somewhat reasonable was returned.
As you move further away from the endpoints, the interpolant decays to its average on the interval.

[@https://link.springer.com/book/10.1007%2F978-1-4612-0599-9 Numerical Analysis, Graduate Texts in Mathematics, 181, Rainer Kress]

for more details.

[endsect] [/section:cubic_b_over Overview of Cubic B-Spline Interpolation]

[section:cubic_b_spline Header]

[heading Accuracy]

By far the greatest source of error is the estimation of the derivative at the endpoint.
If you know the endpoint derivatives, you should certainly provide them; however, in the vast majority of cases,
this is unknown, and the constructor does a reasonable job trying to figure it out.

[heading Testing]

Since the interpolant obeys ['s(x[sub j]) = f(x[sub j])'] at all interpolation points,
the tests generate random data and evaluate the interpolant at the interpolation points,
validating that equality with the data holds.

In addition, constant, linear, and quadratic functions are interpolated to ensure that the interpolant behaves as expected.

[endsect] [/section:cubic_b_spline Header]

[endsect] [/section:cubic_b Cubic B-spline interpolation]

