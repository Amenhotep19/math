[/
  Copyright 2017 Nick Thompson

  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:catmull_rom Catmull-Rom Splines]

[heading Synopsis]

``
#include <boost/math/interpolators/catmull_rom.hpp>

namespace boost{ namespace math{
    template<class Real, class Point, size_t dimension>
    class catmull_rom
    {
    public:
        catmull_rom(const Real* const points, size_t num_points, bool closed = false, Real alpha = (Real) 1/ (Real) 2)

        Real operator()(Real s) const;

        Real max_parameter() const;

        Real parameter_at_point(size_t i) const;

        Point prime(Real s) const;
    };

}}
``

[heading Description]

Catmull-Rom splines are a family of interpolating curves which are commonly used in computer graphics and animation.
Catmull-Rom splines enjoy the following nice properties:

* Affine invariance: The interpolant commutes with affine transformations.
* Local support of the basis functions: This gives stability and fast evaluation.
* Smoothness
* Interpolation of control points: Many curves (such as Bezier) are *approximating*, they do not pass through their control points. This makes them more difficult to use than interpolating splines.

The `catmull_rom` class provided by boost creates a cubic Catmull-Rom spline from an array of points in any dimension.
Since there are numerous ways to represent a point in /n/-dimensional space,
the class attempts to be flexible by templating on the point type.
The requirement of the point type is that it must have a dereference operator defined (e.g., `p[0]` is not a syntax error),
it must be able to be dereferenced up to `dimension -1`, and `p[i]` is of type `Real`.
The basic usage is shown here:

    std::vector<std::array<Real, 3>> points(4);
    points[0] = {0,0,0};
    points[1] = {1,0,0};
    points[2] = {0,1,0};
    points[3] = {0,0,1};
    catmull_rom<Real, std::array<Real, 3>, 3> cr(points.data(), points.size());
    // Interpolate at s = 0.1:
    auto point = cr(0.1);

The spline can be either open or *closed*, meaning that there is some /t/ such /P(t) = P(0)/.
The default is open, but this can be easily changed:

    // closed = true
    catmull_rom<Real, std::array<Real, 3>, 3> cr(points.data(), points.size(), true);

Inside `catmull_rom`, the Catmull-Rom curve is represented as closed.
This is because an open Catmull-Rom curve is *implicitly closed*, but the closing point is the zero vector.
There is no reason to suppose that the zero vector is a better closing point than the endpoint (or any other point, for that matter),
so traditionally Catmull-Rom splines leave the segment between the first and second point undefined,
as well as the segment between the second-to-last and last point.
We find this property of the traditional implementation of Catmull-Rom splines annoying and confusing to the user.
Hence internally, we close the curve so that the first and last segments are defined.
Of course, this causes the *tangent* vectors to the first and last points to be bizarre.
This is a "pick your poison" design decision-either the curve cannot interpolate in its first and last segments,
or the tangents along the first and last segments are meaningless.

Since the routine internally represents the curve as closed,
a question arises: Why does the user have to specify if the curve is open or closed?
The answer is that the parameterization is chosen by the routine,
so it is of interest to the user to understand the values where a meaningful result is returned.

    Real max_s = cr.max_parameter();

If you attempt to interpolate for `s > max_s`, an exception is thrown.
If the curve is closed, then `cr(max_s) = p0`, where `p0` is the first point on the curve.
If the curve is open, then `cr(max_s) = pf`, where `pf` is the final point on the curve.


The Catmull-Rom curve admits an infinite number of parameterizations.
The default parameterization of the `catmull_rom` class is the so-called *centripedal* parameterization.
This parameterization has been shown to be the only parameterization that does not have cusps or self-intersections within segments.
However, for advanced users, other parameterizations can be chosen using the /alpha/ parameter:

   // alpha = 1 is the "chordal" parameterization.
   catmull_rom<Real, std::array<Real, 3>, 3> cr(points.data(), points.size(), false, (Real) 1);


Finally, the tangent vector to any point of the curve can be discovered via

    Real s = 0.1;
    Point tangent = cr.prime(s);

Since the magnitude of the tangent vector is dependent on the parameterization,
it is not as meaningful as (say) arc-length parameterization.
However, its direction is meaningful, so the user may wish to normalize this result.

[heading Examples]

[import ../../example/catmull_rom_example.cpp]

[section:catmull_rom_refs References]

* Cem Yuksel, Scott Schaefer, and John Keyser, ['Parameterization and applications of Catmull–Rom curves], Computer-Aided Design 43 (2011) 747–755.
* Phillip J. Barry and Ronald N. Goldman, ['A Recursive Evaluation Algorithm for a Class of Catmull-Rom Splines], Computer Graphics, Volume 22, Number 4, August 1988

[endsect]
[endsect] [/section:catmull_rom Catmull-Rom Splines]
