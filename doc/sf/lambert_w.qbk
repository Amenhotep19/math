[section:lambert_w Lambert W function]

[h4:synopsis Synopsis]

``
#include <boost/math/special_functions/lambert_w.hpp>
``
   namespace boost { namespace math {

   template <class T>
   ``__sf_result`` lambert_w(T x);

   template <class T, class ``__Policy``>
   ``__sf_result`` lambert_w(T x, const ``__Policy``&);

   } // namespace boost
   } // namespace math

[h4:description Description]

The __Lambert_W is the solution of the equation W[dot]e[super W] = x.
It is also called the Omega function, the inverse function of f(W) = W e[super W].

On the x-interval \[0, [inf]\] there is just one real solution.
On the interval (-1/e, 0) there are two real solutions on two branches called variously W0, W-1, Wp, Wm.
Only one, the so-called principal branch W0 or Wp, is provided by this implementation.

The function is described in Wolfram Mathworld [@http://mathworld.wolfram.com/LambertW-Function.html [^Lambert W function] ].
The principal value of the Lambert W-function is implemented in the Wolfram Language as ProductLog[z].

__WolframAlpha has provided some reference values for testing.
For example, the output from [@https://www.wolframalpha.com/input/?i=productlog(1)] is 0.56714329040978387299996866221035554975381578718651.

Also using the [@https://www.wolframalpha.com Wolfram language], [^N\[ProductLog\[-1\], 50] produces the same output.

The final __Policy argument is optional and can be used to control the behaviour of the function:
how it handles errors, what level of precision to use, etc.

Refer to __policy_section for more details.

[h4:examples Examples]

[import ../../example/lambert_w_example.cpp]

[lambert_w_example_1]

[lambert_w_output_1]

The source of this example is at [@../../example/lambert_w_example.cpp lambert_w_example.cpp]

[h4:accuracy Accuracy]

All the functions usually return values within two ULP (unit in the last place) for the floating-point type.
Values of x close to the boundary of real values at `x ~= -exp(-1))`, about -0.367879,
approach the singularity result of -1,
but never more accurate than `1 - sqrt(epsilon)`, for `double`, about 0.99999999.

[h4:implemention Implementation]

There are many previous implementations with increasing accuracy and speed.

For most of the range of arguments, some initial approximation is followed by a single refinement,
often using Halley or similar method, gives a useful precision.
For the most precise results possible, for C++ the nearest representation,
iterative refinements using Halley's method are needed,
perhaps using a higher precision type for intermediate computation,
finally casting back to the smaller desired result type.
This scheme is used, for example, using arbitrary precision arithmetic by Maple and Wolfram.

For argument values near the singularity and near zero, other approximations are often used,
possibly followed by refinement.



One real-only implementation is based on an algorithm by__Luu_thesis,
(see routine 11 on page 98 for his Lambert W algorithm).

This implementation is based on Thomas Luu's code posted at
[@https://svn.boost.org/trac/boost/ticket/11027 Boost Trac \#11027].

It has been implemented from Luu's algorithm but templated on RealType parameter and result
and handles both __fundamental_types (float, double, long double), __multiprecision,
and also has been tested with a proposed fixed_point type.

A first approximation is computed using the method of Barry et al (see references 5 & 6 below).
(For users only requiring an accuracy of relative accuracy of 0.02%, this function might suffice).

We considered using [@https://en.wikipedia.org/wiki/Newton%27s_method  Newton/Raphson's method]
``
  f(w) = w e^w -z = 0 // Luu equation 6.37
  f'(w) = e^w (1 + w), Wolfram alpha (d)/(dw)(f(w) = w exp(w) - z) = e^w (w + 1)
  if (f(w) / f'(w) -1 < tolerance
  w1 = w0 - (expw0 * (w0 + 1)); // Refine new Newton/Raphson estimate.
``
but concluded that since Newton/Raphson's method takes typically 6 iterations to converge within tolerance,
whereas Halley usually takes only 1 to 3 iterations to achieve an result within 1 __ULP,
so Newton/Raphson's method unlikely to be quicker
than the additional cost of computating the 2nd derivative for Halley's method.

[h4:faster_implementation Implementing Faster Algorithms]

Many applications of the Lambert W function make repeated evaluations for Monte Carlo methods,
for which applications, speed is important.
Luu and Chapeau-Blondeau and Monir provide typical usage examples.

A more recent paper by Fukushima makes important observation that much of the execution time of all
previous iterative algorithms was spent evaluating transcendental functions, mainly exp.
He has put a lot of work into avoiding any slow transcendental functions using lookup tables,
bisection followed by a single Schroeder refinement.
Theoretical and practical tests confirm that this gives results with a known error bound.

For types more precise than double, he shows that it is best to use the double estimate
as a starting point for refinement using Halley or other methods.

For the less well-behaved regions for arguments near zero and near the singularity at -1/e,
some series functions are provided.

However, though these give results within several epsilon of the nearest representable result,
they do not get as close as is possible further refinement, usually within one or two epsilon.

So, as usual, there is a compromise between execution speed and accuracy.

To allow users more control, this implementation provides the best possible accuracy by default,
(Boost.Math generally prefers accuracy over speed)
but will stop at intermediate stages if the precision specifies in the policy has been met,
perhaps halving the execution time.




The implementation details are in [@../../include/boost/math/special_functions/lambert_w.hpp lambert_w.hpp]

[h5 Other implmentations]

The Lambert W has also been discussed in a [@http://lists.boost.org/Archives/boost/2016/09/230819.php Boost thread].
This also gives link to a prototype version by which also handles complex results [^(x < -exp(-1)], about -0.367879).

[@https://github.com/CzB404/lambert_w/ Balazs Cziraki 2016]
Physicist, PhD student at Eotvos Lorand University, ELTE TTK Institute of Physics, Budapest.
has also produces a prototype C++ library that can compute the Lambert W function for floating point
[*and complex number types].
This is not implemented here but might be completed in the future.


[h4:references References]

# NIST Digital Library of Mathematical Functions. [@http://dlmf.nist.gov/4.13.F1].

# [@http://www.orcca.on.ca/LambertW/ Lambert W Poster],
R. M. Corless, G. H. Gonnet, D. E. G. Hare, D. J. Jeffery and D. E. Knuth,
On the Lambert W function Advances in Computational Mathematics, Vol 5, (1996) pp 329-359.

# [@https://people.sc.fsu.edu/~jburkardt/f_src/toms443/toms443.html TOMS443],
Andrew Barry, S. J. Barry, Patricia Culligan-Hensley,
Algorithm 743: WAPR - A Fortran routine for calculating real values of the W-function,[br]
ACM Transactions on Mathematical Software, Volume 21, Number 2, June 1995, pages 172-181.[br]
BISECT approximates the W function using bisection (GNU licence).
Original FORTRAN77 version by Andrew Barry, S. J. Barry, Patricia Culligan-Hensley,
this version by C++ version by John Burkardt.
# [@https://people.sc.fsu.edu/~jburkardt/f_src/toms743/toms743.html TOMS743] Fortran 90 (updated 2014).

Initial guesses based on:

# D.A. Barry, J.-Y. Parlange, L. Li, H. Prommer, C.J. Cunningham, and
F. Stagnitti. Analytical approximations for real values of the Lambert
W-function. Mathematics and Computers in Simulation, 53(1), 95-103 (2000).

# D.A. Barry, J.-Y. Parlange, L. Li, H. Prommer, C.J. Cunningham, and
F. Stagnitti. Erratum to analytical approximations for real values of the
Lambert W-function. Mathematics and Computers in Simulation, 59(6):543-543, 2002.

A PDF of the full [@http://www.paper.edu.cn/scholar/downpaper/liling116674-201210-19 paper] is available.

# C++ __CUDA version of Luu algorithm, [@https://github.com/thomasluu/plog/blob/master/plog.cu plog].

# __Luu_thesis, see routine 11, page 98 for Lambert W algorithm.

# Having Fun with Lambert W(x) Function, Darko Veberic
University of Nova Gorica, Slovenia IK, Forschungszentrum Karlsruhe, Germany, J. Stefan Institute, Ljubljana, Slovenia.

# Fran[ccedil]ois Chapeau-Blondeau and Abdelilah Monir, Numerical Evaluation of the Lambert W Function and Application to Generation of Generalized
Gaussian Noise With Exponent 1/2, IEEE Transactions on Signal Processing, 50(9) (2002) 2160 - 2165.

# Toshio Fukushima, Precise and fast computation of Lambert W-functions without transcendental function evaluations, Journal of Computational and Applied
Mathematics, 244 (2013) 77-89.

[endsect] [/section:lambert_w Lambert W function]

[/
  Copyright 2016 John Maddock, Paul A. Bristow, Thomas Luu.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt
  or copy at http://www.boost.org/LICENSE_1_0.txt).
]
