<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Examples of Root-Finding (with and without derivatives)</title>
<link rel="stylesheet" href="../../math.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.77.1">
<link rel="home" href="../../index.html" title="Math Toolkit 2.1.0">
<link rel="up" href="../roots.html" title="Root finding">
<link rel="prev" href="roots_deriv.html" title="Root Finding With Derivatives: Newton-Raphson, Halley &amp; Schroeder">
<link rel="next" href="brent_minima.html" title="Locating Function Minima using Brent's algorithm">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="roots_deriv.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../roots.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="brent_minima.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="math_toolkit.roots.root_finding_examples"></a><a class="link" href="root_finding_examples.html" title="Examples of Root-Finding (with and without derivatives)">Examples of
      Root-Finding (with and without derivatives)</a>
</h3></div></div></div>
<p>
        The examples demonstrate how to use the various tools for <a href="http://en.wikipedia.org/wiki/Root-finding_algorithm" target="_top">root
        finding</a>.
      </p>
<p>
        We start with the simple cube root function [cbrt] ( C++ standard function
        name <a href="http://en.cppreference.com/w/cpp/numeric/math/cbrt" target="_top">cbrt</a>)
        showing <a class="link" href="root_finding_examples.html#math_toolkit.roots.root_finding_examples.cbrt_no_derivatives">cube-root
        without derivatives</a>.
      </p>
<p>
        We then show how use of derivatives can improve the speed of convergence.
      </p>
<p>
        (But these examples are only a demonstration and does not try to make the
        ultimate improvements of a 'real-life' implementation, for example, of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">math</span><span class="special">::</span><span class="identifier">cbrt</span></code>, mainly by using a better computed
        initial 'guess' at <a href="../../../../../../libs/math/include/boost/math/special_functions/cbrt.hpp" target="_top">cbrt.hpp</a>).
      </p>
<p>
        Then we show how a higher root (<a class="link" href="root_finding_examples.html#math_toolkit.roots.root_finding_examples.fifth_root">fifth
        root</a>) <sup>5</sup>&#8730; can be computed, and in <a href="../../../../example/root_finding_n_example.cpp" target="_top">root_finding_n_example.cpp</a>
        a generic method for the <a class="link" href="root_finding_examples.html#math_toolkit.roots.root_finding_examples.nth_root">nth
        root</a> that constructs the derivatives at compile-time.
      </p>
<p>
        These methods should be applicable to other functions that can be differentiated
        easily.
      </p>
<h4>
<a name="math_toolkit.roots.root_finding_examples.h0"></a>
        <span class="phrase"><a name="math_toolkit.roots.root_finding_examples.no_derivatives"></a></span><a class="link" href="root_finding_examples.html#math_toolkit.roots.root_finding_examples.no_derivatives">Finding
        a root without derivatives</a>
      </h4>
<p>
        First some <code class="computeroutput"><span class="preprocessor">#includes</span></code> that
        will be needed.
      </p>
<p>
        [root_finding_include_1]
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          For clarity, <code class="computeroutput"><span class="keyword">using</span></code> statements
          are provided to list what functions are being used in this example: you
          can, of course, partly or fully qualify the names in other ways. (For your
          application, you may wish to extract some parts into header files, but
          you should never use <code class="computeroutput"><span class="keyword">using</span></code>
          statements globally in header files).
        </p></td></tr>
</table></div>
<p>
        Let's suppose we want to find the root of a number <span class="emphasis"><em>a</em></span>,
        and to start, compute the cube root.
      </p>
<p>
        So the equation we want to solve is:
      </p>
<p>
        &#8192;&#8192; <span class="emphasis"><em>f(x) = x&#179; -a</em></span>
      </p>
<p>
        We will first solve this without using any information about the slope or
        curvature of the cube root function.
      </p>
<p>
        Fortunately, the cube root function is 'Really Well Behaved' in that it is
        monotonic and has only one root (we leave negative values 'as an exercise
        for the student').
      </p>
<p>
        We then show how adding what we can know about this function, first just
        the slope, the 1st derivation <span class="emphasis"><em>f'(x)</em></span>, will speed homing
        in on the solution.
      </p>
<p>
        Lastly we show how adding the curvature <span class="emphasis"><em>f''(x)</em></span> too will
        speed convergence even more.
      </p>
<h4>
<a name="math_toolkit.roots.root_finding_examples.h1"></a>
        <span class="phrase"><a name="math_toolkit.roots.root_finding_examples.cbrt_no_derivatives"></a></span><a class="link" href="root_finding_examples.html#math_toolkit.roots.root_finding_examples.cbrt_no_derivatives">Cube
        root function without derivatives</a>
      </h4>
<p>
        First we define a function object (functor):
      </p>
<p>
        [root_finding_noderiv_1]
      </p>
<p>
        Implementing the cube root function itself is fairly trivial now: the hardest
        part is finding a good approximation to begin with. In this case we'll just
        divide the exponent by three. (There are better but more complex guess algorithms
        used in 'real-life'.)
      </p>
<p>
        [root_finding_noderiv_2]
      </p>
<p>
        This snippet from <code class="computeroutput"><span class="identifier">main</span><span class="special">()</span></code>
        in <a href="../../../../example/root_finding_example.cpp" target="_top">root_finding_example.cpp</a>
        shows how it can be used.
      </p>
<p>
        [root_finding_main_1]
      </p>
<pre class="programlisting">  cbrt_noderiv(27) = 3
  cbrt_noderiv(28) = 3.0365889718756618
</pre>
<p>
        The result of <code class="computeroutput"><span class="identifier">bracket_and_solve_root</span></code>
        is a <a href="http://www.cplusplus.com/reference/utility/pair/" target="_top">pair</a>
        of values that could be displayed.
      </p>
<p>
        Tthe number of bits separating them can be found using <code class="computeroutput"><span class="identifier">float_distance</span><span class="special">(</span><span class="identifier">r</span><span class="special">.</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">r</span><span class="special">.</span><span class="identifier">second</span><span class="special">)</span></code>. The distance is zero (ideal) for 3<sup>3</sup> = 27
        but <code class="computeroutput"><span class="identifier">float_distance</span><span class="special">(</span><span class="identifier">r</span><span class="special">.</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">r</span><span class="special">.</span><span class="identifier">second</span><span class="special">)</span> <span class="special">=</span> <span class="number">3</span></code> for cube
        root of 28 with this function. The result (avoiding overflow) is midway between
        these two values.
      </p>
<h4>
<a name="math_toolkit.roots.root_finding_examples.h2"></a>
        <span class="phrase"><a name="math_toolkit.roots.root_finding_examples.cbrt_1st_derivative"></a></span><a class="link" href="root_finding_examples.html#math_toolkit.roots.root_finding_examples.cbrt_1st_derivative">Cube
        root function with 1st derivative (slope)</a>
      </h4>
<p>
        We now solve the same problem, but using more information about the function,
        to show how this can speed up finding the best estimate of the root.
      </p>
<p>
        For the root function, the 1st differential (the slope of the tangent to
        a curve at any point) is known.
      </p>
<p>
        This algorithm is similar to this <a href="http://en.wikipedia.org/wiki/Nth_root_algorithm" target="_top">nth
        root algorithm</a>.
      </p>
<p>
        If you need some reminders, then <a href="http://en.wikipedia.org/wiki/Derivative#Derivatives_of_elementary_functions" target="_top">Derivatives
        of elementary functions</a> may help.
      </p>
<p>
        Using the rule that the derivative of <span class="emphasis"><em>x<sup>n</sup></em></span> for positive
        n (actually all nonzero n) is <span class="emphasis"><em>n x<sup>n-1</sup></em></span>, allows us to get
        the 1st differential as <span class="emphasis"><em>3x<sup>2</sup></em></span>.
      </p>
<p>
        To see how this extra information is used to find a root, view <a href="http://en.wikipedia.org/wiki/Newton%27s_method" target="_top">Newton-Raphson
        iterations</a> and the <a href="http://en.wikipedia.org/wiki/Newton%27s_method#mediaviewer/File:NewtonIteration_Ani.gif" target="_top">animation</a>.
      </p>
<p>
        We define a better functor <code class="computeroutput"><span class="identifier">cbrt_functor_deriv</span></code>
        that returns both the evaluation of the function to solve, along with its
        first derivative:
      </p>
<p>
        To '<span class="emphasis"><em>return</em></span>' two values, we use a <a href="http://en.cppreference.com/w/cpp/utility/pair" target="_top">std::pair</a>
        of floating-point values.
      </p>
<p>
        [root_finding_1_deriv_1]
      </p>
<p>
        The result of <a href="../../../../../../libs/math/include/boost/math/tools/roots.hpp" target="_top"><code class="computeroutput"><span class="identifier">newton_raphson_iterate</span></code></a> function
        is a single value.
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          There is a compromise between accuracy and speed when chosing the value
          of <code class="computeroutput"><span class="identifier">digits</span></code>. The simplest
          approach is to use <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">digits</span></code>,
          the maximum possible, but this may mean some inefficient iterations. A
          good compromise may be to use <code class="computeroutput"><span class="number">3</span> <span class="special">*</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">digits</span><span class="special">/</span><span class="number">4</span></code>. See below.
        </p></td></tr>
</table></div>
<p>
        It is possible to tell if the call met the accuracy set in <code class="computeroutput"><span class="identifier">get_digits</span></code> by comparing the number of iterations,
        updated in <code class="computeroutput"><span class="identifier">it</span></code>, with the maximum
        allowed in <code class="computeroutput"><span class="identifier">max_it</span></code>.
      </p>
<p>
        Using the test data in <a href="../../../../test/test_cbrt.cpp" target="_top">/test/test_cbrt.cpp</a>
        this found the cube root exact to the last digit in every case, and in no
        more than 6 iterations at double precision. However, you will note that a
        high precision was used in this example, exactly what was warned against
        earlier on in these docs! In this particular case it is possible to compute
        <span class="emphasis"><em>f(x)</em></span> exactly and without undue cancellation error, so
        a high limit is not too much of an issue.
      </p>
<p>
        However, reducing the limit to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">digits</span> <span class="special">*</span> <span class="number">2</span> <span class="special">/</span> <span class="number">3</span></code>
        gave full precision in all but one of the test cases (and that one was out
        by just one bit). The maximum number of iterations remained 6, but in most
        cases was reduced by one.
      </p>
<p>
        Note also that the above code omits a probable optimization by computing
        z&#178;
and reusing it, omits error handling, and does not handle negative values
        of z correctly. (These are left as the customary exercise for the reader!)
      </p>
<p>
        The <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">math</span><span class="special">::</span><span class="identifier">cbrt</span></code> function also includes these and other
        improvements.
      </p>
<h4>
<a name="math_toolkit.roots.root_finding_examples.h3"></a>
        <span class="phrase"><a name="math_toolkit.roots.root_finding_examples.cbrt_2_derivatives"></a></span><a class="link" href="root_finding_examples.html#math_toolkit.roots.root_finding_examples.cbrt_2_derivatives">Cube
        root with 1st &amp; 2nd derivative (slope &amp; curvature)</a>
      </h4>
<p>
        Next we define yet another even better functor <code class="computeroutput"><span class="identifier">cbrt_functor_2deriv</span></code>
        that returns both the evaluation of the function to solve, along with its
        first <span class="bold"><strong>and second</strong></span> derivative:
      </p>
<p>
        &#8192;&#8192;<span class="emphasis"><em>f''(x) = 6x</em></span>
      </p>
<p>
        using information about both slope and curvature to speed convergence.
      </p>
<p>
        To <span class="emphasis"><em>'return'</em></span> three values, we use a <code class="computeroutput"><span class="identifier">tuple</span></code>
        of three floating-point values: [root_finding_2deriv_1]
      </p>
<p>
        The function <code class="computeroutput"><span class="identifier">halley_iterate</span></code>
        also returns a single value, and the number of iterations will reveal if
        it met the convergence criterion set by <code class="computeroutput"><span class="identifier">get_digits</span></code>.
      </p>
<p>
        The no-derivative method gives a result of
      </p>
<pre class="programlisting"><span class="identifier">cbrt_noderiv</span><span class="special">(</span><span class="number">28</span><span class="special">)</span> <span class="special">=</span> <span class="number">3.0365889718756618</span>
</pre>
<p>
        with a 3 bits distance between the bracketed values, whereas the derivative
        methods both converge to a single value
      </p>
<pre class="programlisting"><span class="identifier">cbrt_2deriv</span><span class="special">(</span><span class="number">28</span><span class="special">)</span> <span class="special">=</span> <span class="number">3.0365889718756627</span>
</pre>
<p>
        which we can compare with the <a href="../../../../../../libs/math/doc/html/math_toolkit/powers/cbrt.html" target="_top">boost::math::cbrt</a>
      </p>
<pre class="programlisting"><span class="identifier">cbrt</span><span class="special">(</span><span class="number">28</span><span class="special">)</span>              <span class="special">=</span> <span class="number">3.0365889718756627</span>
</pre>
<p>
        Note that the iterations are set to stop at just one-half of full precision,
        and yet, even so, not one of the test cases had a single bit wrong. What's
        more, the maximum number of iterations was now just 4.
      </p>
<p>
        Just to complete the picture, we could have called <a class="link" href="roots_deriv.html#math_toolkit.roots.roots_deriv.schroeder"><code class="computeroutput"><span class="identifier">schroeder_iterate</span></code></a> in the last example:
        and in fact it makes no difference to the accuracy or number of iterations
        in this particular case. However, the relative performance of these two methods
        may vary depending upon the nature of <span class="emphasis"><em>f(x)</em></span>, and the
        accuracy to which the initial guess can be computed. There appear to be no
        generalisations that can be made except "try them and see".
      </p>
<p>
        Finally, had we called <code class="computeroutput"><span class="identifier">cbrt</span></code>
        with <a href="http://shoup.net/ntl/doc/RR.txt" target="_top">NTL::RR</a> set to
        1000 bit precision (about 300 decimal digits), then full precision can be
        obtained with just 7 iterations. To put that in perspective, an increase
        in precision by a factor of 20, has less than doubled the number of iterations.
        That just goes to emphasise that most of the iterations are used up getting
        the first few digits correct: after that these methods can churn out further
        digits with remarkable efficiency.
      </p>
<p>
        Or to put it another way: <span class="emphasis"><em>nothing beats a really good initial guess!</em></span>
      </p>
<h4>
<a name="math_toolkit.roots.root_finding_examples.h4"></a>
        <span class="phrase"><a name="math_toolkit.roots.root_finding_examples.fifth_root"></a></span><a class="link" href="root_finding_examples.html#math_toolkit.roots.root_finding_examples.fifth_root">Fifth-root
        function</a>
      </h4>
<p>
        Let's now suppose we want to find the <span class="bold"><strong>fifth root</strong></span>
        of a number a.
      </p>
<p>
        The equation we want to solve is :
      </p>
<p>
        &#8192;&#8192;<span class="emphasis"><em>f</em></span>(x) = x<sup>5</sup> -a
      </p>
<p>
        If your differentiation is a little rusty (or you are faced with an function
        whose complexity makes differentiation daunting), then you can get help,
        for example, from the invaluable <a href="http://www.wolframalpha.com/" target="_top">WolframAlpha
        site.</a>
      </p>
<p>
        For example, entering the commmand: <code class="computeroutput"><span class="identifier">differentiate</span>
        <span class="identifier">x</span> <span class="special">^</span> <span class="number">5</span></code>
      </p>
<p>
        or the Wolfram Language command: <code class="computeroutput"> <span class="identifier">D</span><span class="special">[</span><span class="identifier">x</span> <span class="special">^</span>
        <span class="number">5</span><span class="special">,</span> <span class="identifier">x</span><span class="special">]</span></code>
      </p>
<p>
        gives the output: <code class="computeroutput"><span class="identifier">d</span><span class="special">/</span><span class="identifier">dx</span><span class="special">(</span><span class="identifier">x</span>
        <span class="special">^</span> <span class="number">5</span><span class="special">)</span> <span class="special">=</span> <span class="number">5</span>
        <span class="identifier">x</span> <span class="special">^</span> <span class="number">4</span></code>
      </p>
<p>
        and to get the second differential, enter: <code class="computeroutput"><span class="identifier">second</span>
        <span class="identifier">differentiate</span> <span class="identifier">x</span>
        <span class="special">^</span> <span class="number">5</span></code>
      </p>
<p>
        or the Wolfram Language command: <code class="computeroutput"><span class="identifier">D</span><span class="special">[</span><span class="identifier">x</span> <span class="special">^</span>
        <span class="number">5</span><span class="special">,</span> <span class="special">{</span> <span class="identifier">x</span><span class="special">,</span>
        <span class="number">2</span> <span class="special">}]</span></code>
      </p>
<p>
        to get the output: <code class="computeroutput"><span class="identifier">d</span> <span class="special">^</span>
        <span class="number">2</span> <span class="special">/</span> <span class="identifier">dx</span> <span class="special">^</span> <span class="number">2</span><span class="special">(</span><span class="identifier">x</span> <span class="special">^</span>
        <span class="number">5</span><span class="special">)</span> <span class="special">=</span> <span class="number">20</span> <span class="identifier">x</span>
        <span class="special">^</span> <span class="number">3</span></code>
      </p>
<p>
        To get a reference value, we can enter: <code class="literal">fifth root 3126</code>
      </p>
<p>
        or: <code class="computeroutput"><span class="identifier">N</span><span class="special">[</span><span class="number">3126</span> <span class="special">^</span> <span class="special">(</span><span class="number">1</span> <span class="special">/</span> <span class="number">5</span><span class="special">),</span> <span class="number">50</span><span class="special">]</span></code>
      </p>
<p>
        to get a result with a precision of 50 decimal digits:
      </p>
<p>
        5.0003199590478625588206333405631053401128722314376
      </p>
<p>
        (We could also get a reference value using <a class="link" href="root_finding_examples.html#math_toolkit.roots.root_finding_examples.multiprecision_root">multiprecision
        root</a>).
      </p>
<p>
        The 1st and 2nd derivatives of x<sup>5</sup> are:
      </p>
<p>
        &#8192;&#8192;<span class="emphasis"><em>f</em></span>'(x) = 5x<sup>4</sup>
      </p>
<p>
        &#8192;&#8192;<span class="emphasis"><em>f</em></span>''(x) = 20x<sup>3</sup>
      </p>
<p>
        [root_finding_fifth_functor_2deriv] [root_finding_fifth_2deriv]
      </p>
<h4>
<a name="math_toolkit.roots.root_finding_examples.h5"></a>
        <span class="phrase"><a name="math_toolkit.roots.root_finding_examples.multiprecision_root"></a></span><a class="link" href="root_finding_examples.html#math_toolkit.roots.root_finding_examples.multiprecision_root">Root-finding
        using Boost.Multiprecision</a>
      </h4>
<p>
        The apocryphally astute reader might, by now, be asking "How do we know
        if this computes the 'right' answer?".
      </p>
<p>
        For most values, there is, sadly, no 'right' answer. This is because values
        can only rarely be exactly represented by C++ floating-point types. What
        we do want is the 'rightest' representation - one that is the nearest representable
        value. (For more about how numbers are represented see <a href="http://en.wikipedia.org/wiki/Floating_point" target="_top">Floating
        point</a>).
      </p>
<p>
        Of course, we might start with finding an external reference source like
        <a href="http://www.wolframalpha.com/" target="_top">Wolfram Alpha</a>, as above,
        but this is not always possible.
      </p>
<p>
        Another way to reassure is to compute 'reference' values at higher precision
        with which to compare the results of our iterative computations using built-in
        like <code class="computeroutput"><span class="keyword">double</span></code>. They should agree
        within the tolerance that was set.
      </p>
<p>
        The result of <code class="computeroutput"><span class="keyword">static_cast</span></code>ing
        to <code class="computeroutput"><span class="keyword">double</span></code> from a higher-precision
        type like <code class="computeroutput"><span class="identifier">cpp_bin_float_50</span></code>
        is guaranteed to be the <span class="bold"><strong>nearest representable</strong></span>
        <code class="computeroutput"><span class="keyword">double</span></code> value.
      </p>
<p>
        For example, the cube root functions in our example for cbrt(28.) return
      </p>
<pre class="programlisting">  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cbrt</span><span class="special">(</span><span class="number">28</span><span class="special">)</span>                       <span class="number">3.0365889718756627</span>

  <span class="identifier">WolframAlpha</span> <span class="identifier">says</span>            <span class="number">3.036588971875662519420809578505669635581453977248111123242141</span><span class="special">...</span>

<span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;(</span><span class="number">3.03658897187566251942080957850</span><span class="special">)</span>
                                            <span class="number">3.0365889718756627</span>

   <span class="identifier">example</span> <span class="identifier">cbrt</span><span class="special">(</span><span class="number">28</span><span class="special">)</span>              <span class="number">3.0365889718756627</span>
</pre>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top">
<p>
          To ensure that all potentially significant decimal digits are displayed
          use <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">max_digits10</span></code> or if not available on older
          platforms or compilers use <code class="computeroutput"><span class="number">2</span> <span class="special">+</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;::</span><span class="identifier">digits</span>
          <span class="special">*</span> <span class="number">3010</span><span class="special">/</span><span class="number">10000</span></code>. Ideally,
          values should agree to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">-</span><span class="identifier">limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">digits10</span></code>
          decimal digits.
        </p>
<p>
          This also means that a 'reference' value to be <span class="bold"><strong>input
          </strong></span>or <code class="computeroutput"><span class="keyword">static_cast</span></code>
          should have at least <code class="computeroutput"><span class="identifier">max_digits10</span></code>
          decimal digits (17 for 64-bit <code class="computeroutput"><span class="keyword">double</span></code>).
        </p>
</td></tr>
</table></div>
<p>
        If we wish to compute <span class="bold"><strong>higher-precision values</strong></span>
        then, on some platforms, we may be able to use <code class="computeroutput"><span class="keyword">long</span>
        <span class="keyword">double</span></code> with a higher precision than
        <code class="computeroutput"><span class="keyword">double</span></code> to compare with the very
        common <code class="computeroutput"><span class="keyword">double</span></code> and/or a more
        efficient built-in quad floating-point type like __float128.
      </p>
<p>
        Almost all platforms can easily use <a href="../../../../../../libs/multiprecision/doc/html/index.html" target="_top">Boost.Multiprecision</a>,
        for example, <a href="http://www.boost.org/doc/libs/1_53_0_beta1/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/cpp_dec_float.html" target="_top">cpp_dec_float</a>
        or a binary type __cpp_bin_float types, to compute values at very much higher
        precision.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          With multiprecision types, it is debatable whether to use the type <span class="emphasis"><em>T</em></span>
          for computing the initial guesses. Type <code class="computeroutput"><span class="keyword">double</span></code>
          is like to be accurate enough for the method used in these examples. This
          would limit the range of possible values to that of <code class="computeroutput"><span class="keyword">double</span></code>.
          There is also the cost of conversion to and from type T to consider. In
          these examples, <code class="computeroutput"><span class="keyword">double</span></code> is
          used via <code class="computeroutput"><span class="keyword">typedef</span> <span class="keyword">double</span>
          <span class="identifier">guess_type</span></code>.
        </p></td></tr>
</table></div>
<p>
        Since the functors and functions used above are templated on the value type,
        we can very simply use them with any of the <a href="../../../../../../libs/multiprecision/doc/html/index.html" target="_top">Boost.Multiprecision</a>
        types.
      </p>
<p>
        Some examples below are 50 decimal digit decimal and binary types (and on
        some platforms a much faster <code class="computeroutput"><span class="identifier">float128</span>
        <span class="identifier">type</span></code> or <code class="computeroutput"><span class="identifier">quad_float</span></code>)
        that we can use with these includes:
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multiprecision</span><span class="special">/</span><span class="identifier">cpp_bin_float</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// For cpp_bin_float_50.</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multiprecision</span><span class="special">/</span><span class="identifier">cpp_dec_float</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// For cpp_dec_float_50.</span>
<span class="preprocessor">#ifndef</span> <span class="identifier">_MSC_VER</span>  <span class="comment">// float128 is not yet supported by Microsoft compiler at 2013.</span>
<span class="preprocessor">#  include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multiprecision</span><span class="special">/</span><span class="identifier">float128</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// Requires libquadmath.</span>
<span class="preprocessor">#endif</span>
</pre>
<p>
        Some using statements simply their use:
      </p>
<pre class="programlisting">  <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">cpp_dec_float_50</span><span class="special">;</span> <span class="comment">// decimal.</span>
  <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">cpp_bin_float_50</span><span class="special">;</span> <span class="comment">// binary.</span>
<span class="preprocessor">#ifndef</span> <span class="identifier">_MSC_VER</span>  <span class="comment">// Not supported by Microsoft compiler.</span>
  <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">float128</span><span class="special">;</span>
<span class="preprocessor">#endif</span>
</pre>
<p>
        They can be used thus:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">.</span><span class="identifier">precision</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">cpp_dec_float_50</span><span class="special">&gt;::</span><span class="identifier">digits10</span><span class="special">);</span>

<span class="identifier">cpp_dec_float_50</span> <span class="identifier">two</span> <span class="special">=</span> <span class="number">2</span><span class="special">;</span> <span class="comment">// </span>
<span class="identifier">cpp_dec_float_50</span>  <span class="identifier">r</span> <span class="special">=</span> <span class="identifier">cbrt_2deriv</span><span class="special">(</span><span class="identifier">two</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cbrt("</span> <span class="special">&lt;&lt;</span> <span class="identifier">two</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

<span class="identifier">r</span> <span class="special">=</span> <span class="identifier">cbrt_2deriv</span><span class="special">(</span><span class="number">2.</span><span class="special">);</span> <span class="comment">// Passing a double, so ADL will compute a double precision result.</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cbrt("</span> <span class="special">&lt;&lt;</span> <span class="identifier">two</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="comment">// cbrt(2) = 1.2599210498948731906665443602832965552806854248047 'wrong' from digits 17 onwards!</span>
<span class="identifier">r</span> <span class="special">=</span> <span class="identifier">cbrt_2deriv</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">cpp_dec_float_50</span><span class="special">&gt;(</span><span class="number">2.</span><span class="special">));</span> <span class="comment">// Passing a cpp_dec_float_50, </span>
<span class="comment">// so will compute a cpp_dec_float_50 precision result.</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cbrt("</span> <span class="special">&lt;&lt;</span> <span class="identifier">two</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">r</span> <span class="special">=</span> <span class="identifier">cbrt_2deriv</span><span class="special">&lt;</span><span class="identifier">cpp_dec_float_50</span><span class="special">&gt;(</span><span class="number">2.</span><span class="special">);</span> <span class="comment">// Explictly a cpp_dec_float_50, so will compute a cpp_dec_float_50 precision result.</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cbrt("</span> <span class="special">&lt;&lt;</span> <span class="identifier">two</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="comment">// cpp_dec_float_50 1.2599210498948731647672106072782283505702514647015</span>
</pre>
<p>
        A reference value computed by <a href="http://www.wolframalpha.com/" target="_top">Wolfram
        Alpha</a> is
      </p>
<pre class="programlisting"><span class="identifier">N</span><span class="special">[</span><span class="number">2</span><span class="special">^(</span><span class="number">1</span><span class="special">/</span><span class="number">3</span><span class="special">),</span> <span class="number">50</span><span class="special">]</span>  <span class="number">1.2599210498948731647672106072782283505702514647015</span>
</pre>
<p>
        which agrees exactly.
      </p>
<p>
        To <span class="bold"><strong>show</strong></span> values to their full precision,
        it is necessary to adjust the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span></code>
        <code class="computeroutput"><span class="identifier">precision</span></code> to suit the type,
        for example:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">show_cube_root</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">value</span><span class="special">)</span>
<span class="special">{</span> <span class="comment">// Demonstrate by printing the root using all definitely significant digits.</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">.</span><span class="identifier">precision</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">digits10</span><span class="special">);</span>
  <span class="identifier">T</span> <span class="identifier">r</span> <span class="special">=</span> <span class="identifier">cbrt_2deriv</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"value = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">value</span> <span class="special">&lt;&lt;</span> <span class="string">", cube root ="</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="keyword">return</span> <span class="identifier">r</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<pre class="programlisting"><span class="identifier">show_cube_root</span><span class="special">(</span><span class="number">2.</span><span class="special">);</span>
<span class="identifier">show_cube_root</span><span class="special">(</span><span class="number">2.L</span><span class="special">);</span>
<span class="identifier">show_cube_root</span><span class="special">(</span><span class="identifier">two</span><span class="special">);</span>
</pre>
<p>
        which outputs:
      </p>
<pre class="programlisting">cbrt(2) = 1.2599210498948731647672106072782283505702514647015

value = 2, cube root =1.25992104989487
value = 2, cube root =1.25992104989487
value = 2, cube root =1.2599210498948731647672106072782283505702514647015
</pre>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top">
<p>
          Be <span class="bold"><strong>very careful</strong></span> about the floating-point
          type <span class="emphasis"><em>T</em></span> that is passed to the root-finding function.
          Carelessly passing a integer by writing <code class="computeroutput"><span class="identifier">cpp_dec_float_50</span>
          <span class="identifier">r</span> <span class="special">=</span>
          <span class="identifier">cbrt_2deriv</span><span class="special">(</span><span class="number">2</span><span class="special">);</span></code> or <code class="computeroutput"><span class="identifier">show_cube_root</span><span class="special">(</span><span class="number">2</span><span class="special">);</span></code> will
          provoke many warnings and compile errors.
        </p>
<p>
          Even <code class="computeroutput"><span class="identifier">show_cube_root</span><span class="special">(</span><span class="number">2.F</span><span class="special">);</span></code> will
          produce warnings because <code class="computeroutput"><span class="keyword">typedef</span>
          <span class="keyword">double</span> <span class="identifier">guess_type</span></code>
          defines the type used to compute the guess and bracket values as <code class="computeroutput"><span class="keyword">double</span></code>.
        </p>
<p>
          Even more treacherous is passing a <code class="computeroutput"><span class="keyword">double</span></code>
          as in <code class="computeroutput"><span class="identifier">cpp_dec_float_50</span> <span class="identifier">r</span> <span class="special">=</span> <span class="identifier">cbrt_2deriv</span><span class="special">(</span><span class="number">2.</span><span class="special">);</span></code> which
          silently gives the 'wrong' result, computing a <code class="computeroutput"><span class="keyword">double</span></code>
          result and <span class="bold"><strong>then</strong></span> converting to <code class="computeroutput"><span class="identifier">cpp_dec_float_50</span></code>! All digits beyond
          <code class="computeroutput"><span class="identifier">max_digits10</span></code> will be incorrect.
          Making the <code class="computeroutput"><span class="identifier">cbrt</span></code> type explicit
          with <code class="computeroutput"><span class="identifier">cbrt_2deriv</span><span class="special">&lt;</span><span class="identifier">cpp_dec_float_50</span><span class="special">&gt;(</span><span class="number">2.</span><span class="special">);</span></code> will
          give you the desired result.
        </p>
</td></tr>
</table></div>
<h4>
<a name="math_toolkit.roots.root_finding_examples.h6"></a>
        <span class="phrase"><a name="math_toolkit.roots.root_finding_examples.nth_root"></a></span><a class="link" href="root_finding_examples.html#math_toolkit.roots.root_finding_examples.nth_root">Generalizing
        to Compute the nth root</a>
      </h4>
<p>
        If desired, we can now further generalize to compute the <span class="emphasis"><em>n</em></span>th
        root by computing the derivatives <span class="bold"><strong>at compile-time</strong></span>
        using the rules for differentiation and the compile-time static function
        <code class="computeroutput"><span class="identifier">pow</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">&gt;</span></code> where
        template parameter <code class="computeroutput"><span class="identifier">N</span></code> is an
        integer. Our functor and function now have an additional template parameter
        <code class="computeroutput"><span class="identifier">N</span></code>, for the root required.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          Since this is a compile-time static process, the resulting code is as efficient
          as as if hand-coded as the cube and fifth-root examples above. The compiler
          should also optimise any repeated multiplications.
        </p></td></tr>
</table></div>
<p>
        Our <span class="emphasis"><em>n</em></span>th root functor is
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">N</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">=</span> <span class="keyword">double</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">nth_functor_2deriv</span>
<span class="special">{</span> <span class="comment">// Functor returning both 1st and 2nd derivatives.</span>
  <span class="identifier">BOOST_STATIC_ASSERT_MSG</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_integral</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">==</span> <span class="keyword">false</span><span class="special">,</span> <span class="string">"Only floating-point type types can be used!"</span><span class="special">);</span>
  <span class="identifier">BOOST_STATIC_ASSERT_MSG</span><span class="special">((</span><span class="identifier">N</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">true</span><span class="special">,</span> <span class="string">"root N must be &gt; 0!"</span><span class="special">);</span>

  <span class="identifier">nth_functor_2deriv</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">to_find_root_of</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">a</span><span class="special">(</span><span class="identifier">to_find_root_of</span><span class="special">)</span>
  <span class="special">{</span> <span class="comment">// Constructor stores value a to find root of, for example:</span>
  <span class="special">}</span>

  <span class="comment">// using boost::math::tuple; // to return three values.</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">T</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span>
  <span class="special">{</span> <span class="comment">// Return f(x), f'(x) and f''(x).</span>
    <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">math</span><span class="special">::</span><span class="identifier">pow</span><span class="special">;</span>
    <span class="identifier">T</span> <span class="identifier">fx</span> <span class="special">=</span> <span class="identifier">pow</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">&gt;(</span><span class="identifier">x</span><span class="special">)</span> <span class="special">-</span> <span class="identifier">a</span><span class="special">;</span> <span class="comment">// Difference (estimate x^n - a).</span>
    <span class="identifier">T</span> <span class="identifier">dx</span> <span class="special">=</span> <span class="identifier">N</span> <span class="special">*</span> <span class="identifier">pow</span><span class="special">&lt;</span><span class="identifier">N</span> <span class="special">-</span> <span class="number">1</span><span class="special">&gt;(</span><span class="identifier">x</span><span class="special">);</span> <span class="comment">// 1st derivative f'(x).</span>
    <span class="identifier">T</span> <span class="identifier">d2x</span> <span class="special">=</span> <span class="identifier">N</span> <span class="special">*</span> <span class="special">(</span><span class="identifier">N</span> <span class="special">-</span> <span class="number">1</span><span class="special">)</span> <span class="special">*</span> <span class="identifier">pow</span><span class="special">&lt;</span><span class="identifier">N</span> <span class="special">-</span> <span class="number">2</span> <span class="special">&gt;(</span><span class="identifier">x</span><span class="special">);</span> <span class="comment">// 2nd derivative f''(x).</span>

    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_tuple</span><span class="special">(</span><span class="identifier">fx</span><span class="special">,</span> <span class="identifier">dx</span><span class="special">,</span> <span class="identifier">d2x</span><span class="special">);</span> <span class="comment">// 'return' fx, dx and d2x.</span>
  <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
  <span class="identifier">T</span> <span class="identifier">a</span><span class="special">;</span> <span class="comment">// to be 'nth_rooted'.</span>
<span class="special">};</span>
</pre>
<p>
        and our <span class="emphasis"><em>n</em></span>th root function is
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">N</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">=</span> <span class="keyword">double</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">nth_2deriv</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">x</span><span class="special">)</span>
<span class="special">{</span> <span class="comment">// return nth root of x using 1st and 2nd derivatives and Halley.</span>

  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">;</span>  <span class="comment">// Help ADL of std functions.</span>
  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">math</span><span class="special">::</span><span class="identifier">tools</span><span class="special">;</span> <span class="comment">// For halley_iterate.</span>

  <span class="identifier">BOOST_STATIC_ASSERT_MSG</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_integral</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">==</span> <span class="keyword">false</span><span class="special">,</span> <span class="string">"Only floating-point type types can be used!"</span><span class="special">);</span>
  <span class="identifier">BOOST_STATIC_ASSERT_MSG</span><span class="special">((</span><span class="identifier">N</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">true</span><span class="special">,</span> <span class="string">"root N must be &gt; 0!"</span><span class="special">);</span>
  <span class="identifier">BOOST_STATIC_ASSERT_MSG</span><span class="special">((</span><span class="identifier">N</span> <span class="special">&gt;</span> <span class="number">1000</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">false</span><span class="special">,</span> <span class="string">"root N is too big!"</span><span class="special">);</span>

  <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">guess_type</span><span class="special">;</span>

  <span class="keyword">int</span> <span class="identifier">exponent</span><span class="special">;</span>
  <span class="identifier">frexp</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">guess_type</span><span class="special">&gt;(</span><span class="identifier">x</span><span class="special">),</span> <span class="special">&amp;</span><span class="identifier">exponent</span><span class="special">);</span> <span class="comment">// Get exponent of z (ignore mantissa).</span>
  <span class="identifier">T</span> <span class="identifier">guess</span> <span class="special">=</span> <span class="identifier">ldexp</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">guess_type</span><span class="special">&gt;(</span><span class="number">1.</span><span class="special">),</span> <span class="identifier">exponent</span> <span class="special">/</span> <span class="identifier">N</span><span class="special">);</span> <span class="comment">// Rough guess is to divide the exponent by n.</span>
  <span class="identifier">T</span> <span class="identifier">min</span> <span class="special">=</span> <span class="identifier">ldexp</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">guess_type</span><span class="special">&gt;(</span><span class="number">1.</span><span class="special">)</span> <span class="special">/</span> <span class="number">2</span><span class="special">,</span> <span class="identifier">exponent</span> <span class="special">/</span> <span class="identifier">N</span><span class="special">);</span> <span class="comment">// Minimum possible value is half our guess.</span>
  <span class="identifier">T</span> <span class="identifier">max</span> <span class="special">=</span> <span class="identifier">ldexp</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">guess_type</span><span class="special">&gt;(</span><span class="number">2.</span><span class="special">),</span> <span class="identifier">exponent</span> <span class="special">/</span> <span class="identifier">N</span><span class="special">);</span> <span class="comment">// Maximum possible value is twice our guess.</span>

  <span class="keyword">int</span> <span class="identifier">digits</span> <span class="special">=</span> <span class="number">2</span> <span class="special">*</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">digits</span> <span class="special">/</span> <span class="number">3</span><span class="special">;</span> <span class="comment">// Two thirds maximum possible binary digits accuracy for type T.</span>
  <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">uintmax_t</span> <span class="identifier">maxit</span> <span class="special">=</span> <span class="number">20</span><span class="special">;</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">uintmax_t</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">maxit</span><span class="special">;</span>
  <span class="identifier">T</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">halley_iterate</span><span class="special">(</span><span class="identifier">nth_functor_2deriv</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">x</span><span class="special">),</span> <span class="identifier">guess</span><span class="special">,</span> <span class="identifier">min</span><span class="special">,</span> <span class="identifier">max</span><span class="special">,</span> <span class="identifier">digits</span><span class="special">,</span> <span class="identifier">it</span><span class="special">);</span>
  <span class="keyword">return</span> <span class="identifier">result</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<pre class="programlisting">    <span class="identifier">show_nth_root</span><span class="special">&lt;</span><span class="number">5</span><span class="special">,</span> <span class="keyword">double</span><span class="special">&gt;(</span><span class="number">2.</span><span class="special">);</span>
    <span class="identifier">show_nth_root</span><span class="special">&lt;</span><span class="number">5</span><span class="special">,</span> <span class="keyword">long</span> <span class="keyword">double</span><span class="special">&gt;(</span><span class="number">2.</span><span class="special">);</span>
<span class="preprocessor">#ifndef</span> <span class="identifier">_MSC_VER</span>  <span class="comment">// float128 is not supported by Microsoft compiler 2013.</span>
    <span class="identifier">show_nth_root</span><span class="special">&lt;</span><span class="identifier">float128</span><span class="special">,</span> <span class="number">5</span><span class="special">&gt;(</span><span class="number">2</span><span class="special">);</span>
<span class="preprocessor">#endif</span>
    <span class="identifier">show_nth_root</span><span class="special">&lt;</span><span class="number">5</span><span class="special">,</span> <span class="identifier">cpp_dec_float_50</span><span class="special">&gt;(</span><span class="number">2</span><span class="special">);</span> <span class="comment">// dec</span>
    <span class="identifier">show_nth_root</span><span class="special">&lt;</span><span class="number">5</span><span class="special">,</span> <span class="identifier">cpp_bin_float_50</span><span class="special">&gt;(</span><span class="number">2</span><span class="special">);</span> <span class="comment">// bin</span>
</pre>
<p>
        produces an output similar to this
      </p>
<p>
        [root_finding_example_output_1]
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top">
<p>
          Take care with the type passed to the function. It is best to pass a <code class="computeroutput"><span class="keyword">double</span></code> or greater-precision floating-point
          type.
        </p>
<p>
          Passing an integer value, for example, <code class="computeroutput"><span class="identifier">nth_2deriv</span><span class="special">&lt;</span><span class="number">5</span><span class="special">&gt;(</span><span class="number">2</span><span class="special">)</span></code> will be
          rejected, while <code class="computeroutput"><span class="identifier">nth_2deriv</span><span class="special">&lt;</span><span class="number">5</span><span class="special">,</span>
          <span class="keyword">double</span><span class="special">&gt;(</span><span class="number">2</span><span class="special">)</span></code> converts
          the integer to <code class="computeroutput"><span class="keyword">double</span></code>.
        </p>
<p>
          Avoid passing a <code class="computeroutput"><span class="keyword">float</span></code> value
          that will provoke warnings (actually spurious) from the compiler about
          potential loss of data, as noted above.
        </p>
</td></tr>
</table></div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          Asking for unreasonable roots, for example, <code class="computeroutput"><span class="identifier">show_nth_root</span><span class="special">&lt;</span><span class="number">1000000</span><span class="special">&gt;(</span><span class="number">2.</span><span class="special">);</span></code>
          may lead to <a href="http://en.wikipedia.org/wiki/Loss_of_significance" target="_top">Loss
          of significance</a> like <code class="computeroutput"><span class="identifier">Type</span>
          <span class="keyword">double</span> <span class="identifier">value</span>
          <span class="special">=</span> <span class="number">2</span><span class="special">,</span> <span class="number">1000000</span><span class="identifier">th</span> <span class="identifier">root</span>
          <span class="special">=</span> <span class="number">1.00000069314783</span></code>.
          Use of the the <code class="computeroutput"><span class="identifier">pow</span></code> function
          is more sensible for this need.
        </p></td></tr>
</table></div>
<p>
        Full code of these examples is at <a href="../../../../example/root_finding_example.cpp" target="_top">root_finding_example.cpp</a>,
        <a href="../../../../example/root_finding_n_example.cpp" target="_top">root_finding_n_example.cpp</a>
        and <a href="../../../../example/root_finding_multiprecision_example.cpp" target="_top">root_finding_multiprecision_example.cpp</a>.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2006-2010, 2012-2014 Nikhar Agrawal,
      Anton Bikineev, Paul A. Bristow, Marco Guazzone, Christopher Kormanyos, Hubert
      Holin, Bruno Lalande, John Maddock, Johan R&#229;de, Gautam Sewani, Benjamin Sobotta,
      Thijs van den Berg, Daryle Walker and Xiaogang Zhang<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="roots_deriv.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../roots.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="brent_minima.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
