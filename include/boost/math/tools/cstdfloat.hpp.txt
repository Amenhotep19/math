Standardized Floating-Point Typedef's

Overview

The header <boost/cstdfloat.hpp> provides standardized
floating-point typedef's having specified widths.
These are useful for writing portable code because they
should behave identically on all platforms.
All typedef's are in namespace boost.

The typedef's include float16_t, float32_t, float64_t, float128_t,
their corresponding least and fast types,
and the corresponding maximum-width type.
The typedef's are based on underlying built-in types
such as float, double, or long double, or based on other compiler-specific
non-standardized types such as __float128.
The underlying types of these typedef's must conform with
the corresponding specifications of binary16, binary32, binary64,
and binary128 in IEEE-754 floating-point format
[http://en.wikipedia.org/wiki/IEEE_floating_point].

The typedef's are based on N3626
[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3626.pdf]
proposed for a new C++14 standard header <cstdfloat> and N1703
[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1703.pdf]
proposed for a new C language standard header <stdfloat.h>.

The 128-bit floating-point type, of great interest in scientific and
numeric programming, is not required in the boost header,
and may not be supplied for all platforms/compilers, because compiler
support for a 128-bit floating-point type is not mandated by either
the C standard or C++ standard.

The following code uses <boost/cstdfloat.hpp> in combination with
<boost/math/special_functions.hpp> to compute a simplified
version of the Jahnke-Emden-Lambda function. Here, we use
a floating-point type with exactly 64 bits (i.e., float64_t).
If we were to use, for instance, built-in double,
then there would be no guarantee that the code would
behave identically on all platforms, with float64_t from
<boost/cstdfloat.hpp>, however, there is. Here, we know that
this code is portable and uses a floating-point type
with approximately 15 decimal digits of precision.

#include <cmath>
#include <boost/cstdfloat.hpp>
#include <boost/math/special_functions.hpp>

boost::float64_t jahnke_emden_lambda(boost::float64_t v, boost::float64_t x)
{
  const boost::float64_t gamma_v_plus_one = boost::math::tgamma(v + 1);
  const boost::float64_t x_half_pow_v     = std::pow(x /2, v);

  return gamma_v_plus_one * boost::math::cyl_bessel_j(x, v) / x_half_pow_v;
}

See cstdfloat_test.cpp for a more detailed test program.


Rationale

The implementation of <boost/cstdfloat.hpp> is designed to utilize <float.h>,
defined in the 1989 C standard. The preprocessor is used to query certain
preprocessor definitions in <float.h> such as FLT_MAX, DBL_MAX, etc.
Based on the results of these queries, an attempt is made to automatically
detect the presence of built-in floating-point types having specified widths.
An unequivocal test regarding conformance with IEEE-754 based on
std::numeric_limits<> is performed with BOOST_STATIC_ASSERT.

The header <boost/cstdfloat.hpp> makes the standardized floating-point
typedef's safely available in namespace boost without placing any names
in namespace std. The intention is to complement rather than compete
with a potential future C++ Standard Library that may contain these typedef's.
Should some future C++ standard include <stdfloat.h> and <cstdfloat>,
then <boost/cstdfloat.hpp> will continue to function, but will become redundant
and may be safely deprecated.

Because <boost/cstdfloat.hpp> is a boost header, its name conform to the
boost header naming conventions, not the C++ Standard Library header
naming conventions.

Please note that <boost/cstdfloat.hpp> can not synthesize or create
a typedef if the underlying type is not provided by the compiler.
For example, if a compiler does not have an underlying floating-point
type with 128 bits (highly sought-after in scientific and numeric programming),
then float128_t and ist corresponding least and fast types are not
provided by <boost/cstdfloat.hpp>.


Caveat Emptor

As an implementation artifact, certain C macro names from <float.h>
may possibly be visible to users of <boost/cstdfloat.hpp>.
Don't rely on using these macros; they are not part of any Boost-specified interface.
Use std::numeric_limits<> for floating-point ranges, etc. instead.


Exact-Width Floating-Point Typedef's

The typedef float#_t, with # replaced by the width, designates a
floating-point type of exactly # bits; for example float32_t denotes
a single-precision floating-point type with 24 binary mantissa digits
(including one xxx bit) and 8 binary exponent digits with approximately
7 decimal digits of precision.

Floating-point types are specified with (optionally) implementation-specific
widths and formats. However, if a platform supports underlying
floating-point types (conformant with IEEE-754) with widths of
16, 32, 64, 128 bits, or any combination thereof,
then <boost/cstdfloat.hpp> does provide the corresponding typedef's
float16_t, float32_t, float64_t, float128_t,
their corresponding least and fast types,
and the corresponding maximum-width type

The absence of float128_t is indicated by the macro BOOST_NO_FLOAT128_T.

Fastest minimum-width floating-point typedef's

The typedef float_least#_t, with # replaced by the width, designates a
floating-point type with a width of at least # bits, such that no
floating-point type with lesser size has at least the specified width.
Thus, float_least32_t denotes the smallest floating-point type with
a width of at least 32 bits.

Minimum-width floating-point types are provided for all existing
exact-width floating-point types on a given platform.

For example, is a platfrom supports float32_t and float64_t,
then float_least32_t and float_least64_t will also be supported, etc.


Fastest minimum-width floating-point typedef's

The typedef float_fast#_t, with # replaced by the width, designates
the fastest floating-point type with a width of at least # bits.

There is no guarantee that these types are fastest for all purposes.
In any case, however, they satisfy the precision and width requirements.

Fastest minimum-width floating-point types are provided for all existing
exact-width floating-point types on a given platform.

For example, is a platfrom supports float32_t and float64_t,
then float_fast32_t and float_fast64_t will also be supported, etc.

Greatest-width floating-point typedef

The typedef floatmax_t designates a floating-point type capable of representing
any value of any floating-point type.

The greatest-width typedef is provided for all platforms.

Floating-Point Constant Macros

All macros of the type BOOST_FLOAT16_C, BOOST_FLOAT32_C, BOOST_FLOAT64_C,
BOOST_FLOAT128_C, BOOST_FLOATMAX_C are always defined after inclusion of
<boost/cstdfloat.hpp>. These allow floating-point constants of at
least the specified width to be declared.

For example:

#include <boost/cstdfloat.hpp>

// Here Pythagoras' constant with approximately 7 decimal digits
// of precision is created with the correct suffix applied:
static const boost::float32_t pi = BOOST_FLOAT32_C3.1415926536); 

// Here the Euler-gamma constant with approximately 34 decimal digits
// of precision is created with the correct suffix applied:
static const boost::float128_t euler = BOOST_FLOAT128_C(0.57721566490153286060651209008240243104216); 
